name: PR Validation

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  TF_VAR_admin_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
  TF_VAR_db_admin_password: ${{ secrets.DB_ADMIN_PASSWORD }}
  TF_VAR_gallery_name: ${{ vars.GALLERY_NAME }}
  TF_VAR_gallery_resource_group_name: ${{ vars.GALLERY_RESOURCE_GROUP }}
  TF_VAR_subnet_id: ${{ vars.SUBNET_ID }}
  TF_VAR_location: ${{ vars.LOCATION }}

jobs:
  # Stage 1: Build Image (if packer files changed)
  build-image:
    name: Build Image
    runs-on: ubuntu-latest
    outputs:
      image_version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for Packer changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            packer:
              - 'packer/drupal-rocky9.pkr.hcl'
              - 'packer/ansible/playbook.yml'
              - 'packer/variables.pkr.hcl'

      - name: Generate version
        id: version
        env:
          FALLBACK_VERSION: "1.4.0"
        run: |
          if [ "${{ steps.changes.outputs.packer }}" == "true" ]; then
            # Azure Compute Gallery requires semver format: Major.Minor.Patch
            # Use 0.0.{PR_NUMBER} for PR builds to distinguish from production versions
            echo "version=0.0.${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "Building new image for PR #${{ github.event.pull_request.number }}"
          else
            echo "version=$FALLBACK_VERSION" >> $GITHUB_OUTPUT
            echo "No packer changes - using fallback image version $FALLBACK_VERSION"
          fi

      - name: Setup Packer
        if: steps.changes.outputs.packer == 'true'
        uses: hashicorp/setup-packer@main
        with:
          version: latest

      - name: Azure CLI Login
        if: steps.changes.outputs.packer == 'true'
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Get base image version
        if: steps.changes.outputs.packer == 'true'
        id: base_version
        run: |
          # Query Azure SIG for the latest base image version
          echo "Querying Azure Shared Image Gallery for latest base image..."
          VERSION=$(az sig image-version list \
            --gallery-name ${{ vars.GALLERY_NAME }} \
            --gallery-image-definition drupal-base-rocky-linux-9 \
            --resource-group ${{ vars.GALLERY_RESOURCE_GROUP }} \
            --query "sort_by([].name, &@)[-1]" -o tsv)

          if [ -z "$VERSION" ]; then
            echo "::error::No base image found in gallery. Run base-image-build.yml first to create a base image."
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using latest base image version from gallery: $VERSION"

      - name: Build image (if changed)
        if: steps.changes.outputs.packer == 'true'
        working-directory: packer
        run: |
          packer init .
          packer build \
            -only='drupal-rocky9*' \
            -var "subscription_id=$ARM_SUBSCRIPTION_ID" \
            -var "client_id=$ARM_CLIENT_ID" \
            -var "client_secret=$ARM_CLIENT_SECRET" \
            -var "tenant_id=$ARM_TENANT_ID" \
            -var "use_azure_cli_auth=false" \
            -var "image_version=${{ steps.version.outputs.version }}" \
            -var "base_image_version=${{ steps.base_version.outputs.version }}" \
            -var "gallery_resource_group_name=${{ vars.GALLERY_RESOURCE_GROUP }}" \
            -var "gallery_name=${{ vars.GALLERY_NAME }}" \
            -var "image_name=drupal-rocky-linux-9" \
            -var "location=${{ vars.LOCATION }}" \
            -var "replication_regions=[\"${{ vars.LOCATION }}\"]" \
            .

  # Stage 2: Deploy Dev Environment
  deploy-dev:
    name: Deploy Dev
    needs: build-image
    runs-on: ubuntu-latest
    environment: dev
    outputs:
      postgresql_fqdn: ${{ steps.outputs.outputs.postgresql_fqdn }}
      dev_vm_ip: ${{ steps.outputs.outputs.public_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: environments/dev
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ vars.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ vars.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=dev/pr-${{ github.event.pull_request.number }}/terraform.tfstate"

      - name: Terraform Apply
        working-directory: environments/dev
        run: |
          terraform apply -auto-approve \
            -var="pr_number=${{ github.event.pull_request.number }}" \
            -var="image_version=${{ needs.build-image.outputs.image_version }}"

      - name: Get Outputs
        id: outputs
        working-directory: environments/dev
        run: |
          echo "postgresql_fqdn=$(terraform output -raw postgresql_fqdn)" >> $GITHUB_OUTPUT
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT

      - name: Sync Database (pg_dump/pg_restore)
        env:
          PROD_DB_HOST: ${{ secrets.PROD_DB_HOST }}
          PROD_DB_USER: ${{ secrets.PROD_DB_USER }}
          PROD_DB_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
          DEV_DB_HOST: ${{ steps.outputs.outputs.postgresql_fqdn }}
          DEV_DB_USER: drupaladmin
          DEV_DB_PASSWORD: ${{ secrets.DB_ADMIN_PASSWORD }}
        run: |
          # Install PostgreSQL client
          sudo apt-get update && sudo apt-get install -y postgresql-client

          # Dump production database
          PGPASSWORD=$PROD_DB_PASSWORD pg_dump \
            -h $PROD_DB_HOST \
            -U $PROD_DB_USER \
            -d drupal \
            --no-owner --no-acl \
            > /tmp/drupal_dump.sql

          # Restore to dev/test database
          PGPASSWORD=$DEV_DB_PASSWORD psql \
            -h $DEV_DB_HOST \
            -U $DEV_DB_USER \
            -d drupal \
            < /tmp/drupal_dump.sql

      - name: Run Dev Validation Tests
        run: |
          DEV_IP="${{ steps.outputs.outputs.public_ip }}"
          echo "Testing health endpoint on $DEV_IP..."

          # Wait for VM to be ready
          for i in {1..30}; do
            if curl -sf http://${DEV_IP}/health; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Waiting for VM... (attempt $i/30)"
            sleep 10
          done

          echo "Health check failed after 30 attempts"
          exit 1

      - name: Post Dev URL to PR
        uses: actions/github-script@v7
        with:
          script: |
            const devUrl = `http://${{ steps.outputs.outputs.public_ip }}`;
            const imageVersion = `${{ needs.build-image.outputs.image_version }}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ðŸ” Dev Environment Ready for Review\n\n**Dev Site URL:** ${devUrl}\n\n**Image Version:** ${imageVersion}\n\nPlease review the dev site, then approve the workflow to proceed to the test environment.\n\n[Approve workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
            });

      - name: Dev Deploy Summary
        run: |
          echo "## Dev Environment Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Site URL:** http://${{ steps.outputs.outputs.public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Version:** ${{ needs.build-image.outputs.image_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Waiting for manual approval before proceeding to test environment." >> $GITHUB_STEP_SUMMARY

  # Stage 3: Dev Review Gate (human approval required)
  dev-review:
    name: Dev Review
    needs: [build-image, deploy-dev]
    runs-on: ubuntu-latest
    environment: dev-review

    steps:
      - name: Dev Review Approved
        run: |
          echo "## Dev Review Approved" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Proceeding to destroy dev VM and deploy test environment." >> $GITHUB_STEP_SUMMARY

  # Stage 4: Deploy Test Environment
  deploy-test:
    name: Deploy Test
    needs: [build-image, deploy-dev, dev-review]
    runs-on: ubuntu-latest
    environment: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      # First, destroy Dev VM (sequential: Dev -> Test)
      - name: Destroy Dev VM
        working-directory: environments/dev
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ vars.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ vars.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=dev/pr-${{ github.event.pull_request.number }}/terraform.tfstate"
          terraform destroy -auto-approve -target=module.dev_vm \
            -var="pr_number=${{ github.event.pull_request.number }}" \
            -var="image_version=${{ needs.build-image.outputs.image_version }}"

      # Deploy Test VM (uses same PostgreSQL)
      - name: Terraform Init (Test)
        working-directory: environments/test
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ vars.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ vars.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=test/pr-${{ github.event.pull_request.number }}/terraform.tfstate"

      - name: Deploy Test VM
        working-directory: environments/test
        run: |
          terraform apply -auto-approve \
            -var="pr_number=${{ github.event.pull_request.number }}" \
            -var="image_version=${{ needs.build-image.outputs.image_version }}"

      - name: Get Test VM IP
        id: outputs
        working-directory: environments/test
        run: |
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT

      - name: Run Test Validation
        run: |
          TEST_IP="${{ steps.outputs.outputs.public_ip }}"
          echo "Testing health endpoint on $TEST_IP..."

          # Wait for VM to be ready
          for i in {1..30}; do
            if curl -sf http://${TEST_IP}/health; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Waiting for VM... (attempt $i/30)"
            sleep 10
          done

          echo "Health check failed after 30 attempts"
          exit 1

      - name: Post Test URL to PR
        uses: actions/github-script@v7
        with:
          script: |
            const testUrl = `http://${{ steps.outputs.outputs.public_ip }}`;
            const imageVersion = `${{ needs.build-image.outputs.image_version }}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âœ… Test Environment Ready\n\n**Test Site URL:** ${testUrl}\n\n**Image Version:** ${imageVersion}\n\nDev and test validation complete. Ready for production deployment approval.`
            });

      - name: Test Deploy Summary
        run: |
          echo "## Test Environment Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Site URL:** http://${{ steps.outputs.outputs.public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Version:** ${{ needs.build-image.outputs.image_version }}" >> $GITHUB_STEP_SUMMARY

  # Stage 5: Ready for Production (requires approval)
  production-ready:
    name: Production Ready
    needs: [build-image, deploy-test]
    runs-on: ubuntu-latest
    environment: production-approval

    steps:
      - name: Production Ready Summary
        run: |
          echo "## Production Ready" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Version:** ${{ needs.build-image.outputs.image_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This image has been validated in both dev and test environments." >> $GITHUB_STEP_SUMMARY
          echo "Ready for production deployment after manual approval." >> $GITHUB_STEP_SUMMARY
